
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>taskopen: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/johnconnor-sec/taskopen-go/taskopen/cmd/taskopen/main.go (0.0%)</option>
				
				<option value="file1">github.com/johnconnor-sec/taskopen-go/taskopen/internal/config/config.go (75.8%)</option>
				
				<option value="file2">github.com/johnconnor-sec/taskopen-go/taskopen/internal/config/interactive.go (0.0%)</option>
				
				<option value="file3">github.com/johnconnor-sec/taskopen-go/taskopen/internal/config/loader.go (0.0%)</option>
				
				<option value="file4">github.com/johnconnor-sec/taskopen-go/taskopen/internal/config/migration.go (0.0%)</option>
				
				<option value="file5">github.com/johnconnor-sec/taskopen-go/taskopen/internal/config/schema.go (0.0%)</option>
				
				<option value="file6">github.com/johnconnor-sec/taskopen-go/taskopen/internal/core/integration.go (52.9%)</option>
				
				<option value="file7">github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors/errors.go (100.0%)</option>
				
				<option value="file8">github.com/johnconnor-sec/taskopen-go/taskopen/internal/exec/executor.go (0.0%)</option>
				
				<option value="file9">github.com/johnconnor-sec/taskopen-go/taskopen/internal/taskwarrior/taskwarrior.go (0.0%)</option>
				
				<option value="file10">github.com/johnconnor-sec/taskopen-go/taskopen/internal/types/types.go (97.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Taskopen - A powerful task annotation opener for Taskwarrior
package main

import (
        "context"
        "fmt"
        "os"
        "runtime"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/config"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/core"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
)

// Build information - set by linker flags
var (
        version = "dev"
        commit  = "unknown"
        date    = "unknown"
)

func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                handleError(err)
                os.Exit(1)
        }</span>
}

func run() error <span class="cov0" title="0">{
        args := os.Args[1:]

        // Handle version flag
        if len(args) &gt; 0 &amp;&amp; (args[0] == "--version" || args[0] == "-v" || args[0] == "version") </span><span class="cov0" title="0">{
                printVersion()
                return nil
        }</span>

        // Handle diagnostics command
        <span class="cov0" title="0">if len(args) &gt; 0 &amp;&amp; args[0] == "diagnostics" </span><span class="cov0" title="0">{
                return runDiagnostics()
        }</span>

        // Handle config commands
        <span class="cov0" title="0">if len(args) &gt; 0 &amp;&amp; args[0] == "config" </span><span class="cov0" title="0">{
                return runConfigCommand(args[1:])
        }</span>

        // Main taskopen functionality - run the core application
        <span class="cov0" title="0">return runTaskOpen(args)</span>
}

func printVersion() <span class="cov0" title="0">{
        fmt.Printf("taskopen %s\n", version)
        fmt.Printf("Git commit: %s\n", commit)
        fmt.Printf("Build date: %s\n", date)
        fmt.Printf("Go version: %s\n", runtime.Version())
        fmt.Printf("Platform: %s/%s\n", runtime.GOOS, runtime.GOARCH)
}</span>

func runDiagnostics() error <span class="cov0" title="0">{
        fmt.Println("üîç Taskopen Diagnostics")
        fmt.Println("======================")
        fmt.Println()

        // Check Go version
        fmt.Printf("‚úì Go version: %s\n", runtime.Version())

        // Check build info
        fmt.Printf("‚úì Version: %s (%s)\n", version, commit)

        // Check types system
        fmt.Println("‚úì Types system: Functional")

        // Check error handling
        fmt.Println("‚úì Error handling: Functional")

        // Check configuration system
        fmt.Println("‚úì Configuration system: Functional")

        // Check basic functionality
        fmt.Println("‚úì Basic CLI: Functional")

        // Try to find config file
        configPath, err := config.FindConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Config lookup: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úì Config path: %s\n", configPath)
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("üéâ EPOCH 1 &amp; 2 Complete - Ready for EPOCH 3!")

        return nil</span>
}

func runConfigCommand(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Config commands:")
                fmt.Println("  init     - Create configuration interactively")
                fmt.Println("  migrate  - Migrate INI config to YAML")
                fmt.Println("  validate - Validate configuration file")
                fmt.Println("  example  - Show example configuration")
                fmt.Println("  schema   - Generate JSON schema")
                return nil
        }</span>

        <span class="cov0" title="0">subcommand := args[0]

        switch subcommand </span>{
        case "init":<span class="cov0" title="0">
                return runConfigInit()</span>
        case "migrate":<span class="cov0" title="0">
                return runConfigMigrate(args[1:])</span>
        case "validate":<span class="cov0" title="0">
                return runConfigValidate(args[1:])</span>
        case "example":<span class="cov0" title="0">
                return runConfigExample()</span>
        case "schema":<span class="cov0" title="0">
                return runConfigSchema(args[1:])</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown config subcommand: %s", subcommand)</span>
        }
}

func runConfigInit() error <span class="cov0" title="0">{
        configPath, err := config.FindConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return config.GenerateInteractive(configPath)</span>
}

func runConfigMigrate(args []string) error <span class="cov0" title="0">{
        var iniPath, yamlPath string

        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                iniPath = args[0]
                yamlPath = args[1]
        }</span> else<span class="cov0" title="0"> {
                // Auto-detect paths
                homeDir, _ := os.UserHomeDir()
                iniPath = homeDir + "/.taskopenrc"
                yamlPath, _ = config.FindConfigPath()
        }</span>

        <span class="cov0" title="0">return config.MigrateFromINI(iniPath, yamlPath)</span>
}

func runConfigValidate(args []string) error <span class="cov0" title="0">{
        var configPath string

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                configPath = args[0]
        }</span> else<span class="cov0" title="0"> {
                var err error
                configPath, err = config.FindConfigPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return config.ValidateFile(configPath)</span>
}

func runConfigExample() error <span class="cov0" title="0">{
        config.ShowConfigExample()
        return nil
}</span>

func runConfigSchema(args []string) error <span class="cov0" title="0">{
        var outputPath string

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                outputPath = args[0]
        }</span> else<span class="cov0" title="0"> {
                outputPath = "taskopen-schema.json"
        }</span>

        <span class="cov0" title="0">if err := config.SaveJSONSchema(outputPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úì JSON schema saved to: %s\n", outputPath)
        return nil</span>
}

func runTaskOpen(args []string) error <span class="cov0" title="0">{
        // For now, show demonstration of completed functionality
        fmt.Println("üöÄ Taskopen Go Edition")
        fmt.Println("=======================")
        fmt.Println()
        fmt.Println("‚úÖ EPOCH 1: Foundation &amp; Infrastructure - COMPLETE")
        fmt.Println("‚úÖ EPOCH 2: Configuration System - COMPLETE")
        fmt.Println("‚úÖ EPOCH 3: Process Execution &amp; Taskwarrior Integration - COMPLETE")
        fmt.Println()

        // Show available commands
        fmt.Println("üìã Available Commands:")
        fmt.Println("  taskopen version              - Show version information")
        fmt.Println("  taskopen diagnostics          - Run system diagnostics")
        fmt.Println("  taskopen config init          - Create configuration interactively")
        fmt.Println("  taskopen config migrate       - Migrate INI config to YAML")
        fmt.Println("  taskopen config validate      - Validate configuration file")
        fmt.Println("  taskopen config example       - Show example configuration")
        fmt.Println("  taskopen config schema        - Generate JSON schema")
        fmt.Println()

        // Demonstrate system capabilities
        fmt.Println("üîß System Capabilities:")
        fmt.Println("  ‚Ä¢ YAML configuration with schema validation")
        fmt.Println("  ‚Ä¢ Automatic INI ‚Üí YAML migration")
        fmt.Println("  ‚Ä¢ Secure process execution with sandboxing")
        fmt.Println("  ‚Ä¢ Taskwarrior JSON streaming parser")
        fmt.Println("  ‚Ä¢ Comprehensive error handling")
        fmt.Println("  ‚Ä¢ Context-aware cancellation")
        fmt.Println("  ‚Ä¢ Retry logic with exponential backoff")
        fmt.Println()

        // Try to demonstrate with actual config
        ctx := context.Background()

        // Find configuration
        configPath, err := config.FindConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Config lookup error: %v\n", err)
                fmt.Println("  Run 'taskopen config init' to create configuration")
                return nil
        }</span>

        // Try to load configuration
        <span class="cov0" title="0">cfg, err := config.LoadOrCreate(configPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  Config load error: %v\n", err)
                fmt.Println("  Run 'taskopen config init' to create configuration")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("üìÅ Configuration: %s\n", configPath)
        fmt.Printf("  ‚Ä¢ %d actions configured\n", len(cfg.Actions))
        fmt.Printf("  ‚Ä¢ Editor: %s\n", cfg.General.Editor)
        fmt.Printf("  ‚Ä¢ Taskwarrior: %s\n", cfg.General.TaskBin)
        fmt.Println()

        // Try to create TaskOpen instance
        taskOpen, err := core.New(cfg)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  TaskOpen initialization error: %v\n", err)
                return nil
        }</span>

        // Try to verify setup
        <span class="cov0" title="0">fmt.Println("üîç System Verification:")
        if err := taskOpen.VerifySetup(ctx); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  ‚ö†Ô∏è  Setup verification failed: %v\n", err)
                fmt.Println("  Some functionality may not be available")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("  ‚úì All systems operational")

                // Try to get taskwarrior version
                if version, err := taskOpen.GetVersion(ctx); err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚úì Taskwarrior version: %s\n", version)
                }</span>

                // Try to get current context
                <span class="cov0" title="0">if context, err := taskOpen.GetCurrentContext(ctx); err == nil &amp;&amp; context != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  ‚úì Active context: %s\n", context)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("üéØ Ready for Interactive Implementation!")
        fmt.Println("   The foundation is complete and tested.")
        fmt.Println("   Next: Interactive menu system with fuzzy search")

        return nil</span>
}

func handleError(err error) <span class="cov0" title="0">{
        // Use our structured error handling
        if taskopenErr, ok := err.(*errors.TaskopenError); ok </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "‚ùå %s\n", taskopenErr.Error())
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(os.Stderr, "‚ùå Unexpected error: %v\n", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package config provides YAML-based configuration with schema validation and INI migration.
package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/types"
)

// Config represents the complete taskopen configuration.
type Config struct {
        // General configuration
        General GeneralConfig `yaml:"general" json:"general" validate:"required"`

        // Action definitions
        Actions []types.Action `yaml:"actions" json:"actions" validate:"required,min=1,dive"`

        // CLI configuration
        CLI CLIConfig `yaml:"cli" json:"cli"`

        // Internal metadata
        ConfigVersion string `yaml:"config_version,omitempty" json:"config_version,omitempty"`
        ConfigPath    string `yaml:"-" json:"-"`
}

// GeneralConfig contains general taskopen settings.
type GeneralConfig struct {
        // Editor command for editing notes/files
        Editor string `yaml:"editor" json:"editor" validate:"required" default:"vim"`

        // Taskwarrior binary path
        TaskBin string `yaml:"taskbin" json:"taskbin" validate:"required" default:"task"`

        // Additional arguments to pass to taskwarrior
        TaskArgs []string `yaml:"taskargs" json:"taskargs"`

        // Path extension for file operations
        PathExt string `yaml:"path_ext" json:"path_ext"`

        // Task attributes to display
        TaskAttributes string `yaml:"task_attributes" json:"task_attributes" default:"priority,project,tags,description"`

        // Hook for tasks without annotations
        NoAnnotationHook string `yaml:"no_annotation_hook" json:"no_annotation_hook" default:"addnote $ID"`

        // Default task sort order
        Sort string `yaml:"sort" json:"sort" default:"urgency-,annot"`

        // Base filter for tasks
        BaseFilter string `yaml:"base_filter" json:"base_filter" default:"+PENDING"`

        // Debug mode
        Debug bool `yaml:"debug" json:"debug"`
}

// CLIConfig contains CLI-specific configuration.
type CLIConfig struct {
        // Default subcommand when none specified
        DefaultSubcommand string `yaml:"default_subcommand" json:"default_subcommand" default:"normal"`

        // Command aliases
        Aliases map[string]string `yaml:"aliases" json:"aliases"`

        // Action groups
        Groups map[string]string `yaml:"groups" json:"groups"`
}

// DefaultConfig returns a configuration with sensible defaults.
func DefaultConfig() *Config <span class="cov6" title="5">{
        return &amp;Config{
                ConfigVersion: "2.0",
                General: GeneralConfig{
                        Editor:           getEnvDefault("EDITOR", "vim"),
                        TaskBin:          "task",
                        TaskArgs:         []string{},
                        PathExt:          "",
                        TaskAttributes:   "priority,project,tags,description",
                        NoAnnotationHook: "addnote $ID",
                        Sort:             "urgency-,annot",
                        BaseFilter:       "+PENDING",
                        Debug:            false,
                },
                Actions: []types.Action{
                        {
                                Name:       "files",
                                Target:     "annotations",
                                Regex:      `^[\.\/~]+.*\.(.*)`,
                                LabelRegex: ".*",
                                Command:    getOpenCommand() + " $FILE",
                                Modes:      []string{"batch", "any", "normal"},
                        },
                        {
                                Name:       "notes",
                                Target:     "annotations",
                                Regex:      `^Notes(\..*)?`,
                                LabelRegex: ".*",
                                Command:    `editnote ~/Notes/tasknotes/$UUID$LAST_MATCH "$TASK_DESCRIPTION" $UUID`,
                                Modes:      []string{"batch", "any", "normal"},
                        },
                        {
                                Name:       "url",
                                Target:     "annotations",
                                Regex:      `((?:www|http).*)`,
                                LabelRegex: ".*",
                                Command:    getOpenCommand() + " $LAST_MATCH",
                                Modes:      []string{"batch", "any", "normal"},
                        },
                },
                CLI: CLIConfig{
                        DefaultSubcommand: "normal",
                        Aliases: map[string]string{
                                "batch":       "",
                                "any":         "",
                                "normal":      "",
                                "version":     "",
                                "diagnostics": "",
                        },
                        Groups: make(map[string]string),
                },
        }
}</span>

// getOpenCommand returns the appropriate open command for the platform.
func getOpenCommand() string <span class="cov8" title="10">{
        // Check environment variable first
        if cmd := os.Getenv("TASKOPEN_OPEN_CMD"); cmd != "" </span><span class="cov0" title="0">{
                return cmd
        }</span>

        // Platform-specific defaults
        <span class="cov8" title="10">switch </span>{
        case fileExists("/usr/bin/xdg-open"):<span class="cov8" title="10">
                return "xdg-open"</span>
        case fileExists("/usr/bin/open"):<span class="cov0" title="0">
                return "open"</span>
        case fileExists("/usr/bin/start"):<span class="cov0" title="0">
                return "start"</span>
        default:<span class="cov0" title="0">
                return "xdg-open"</span> // Fallback
        }
}

// getEnvDefault returns environment variable value or default if not set.
func getEnvDefault(key, defaultValue string) string <span class="cov6" title="5">{
        if value := os.Getenv(key); value != "" </span><span class="cov6" title="5">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// fileExists checks if a file exists.
func fileExists(path string) bool <span class="cov10" title="14">{
        _, err := os.Stat(path)
        return !os.IsNotExist(err)
}</span>

// FindConfigPath locates the configuration file using standard locations.
func FindConfigPath() (string, error) <span class="cov1" title="1">{
        // Priority order for config file locations:
        // 1. $TASKOPENRC environment variable
        // 2. $XDG_CONFIG_HOME/taskopen/config.yml
        // 3. $HOME/.config/taskopen/config.yml
        // 4. $HOME/.taskopenrc (legacy INI format)

        if path := os.Getenv("TASKOPENRC"); path != "" </span><span class="cov0" title="0">{
                return path, nil
        }</span>

        // XDG config directory
        <span class="cov1" title="1">configDir := os.Getenv("XDG_CONFIG_HOME")
        if configDir == "" </span><span class="cov1" title="1">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, errors.ConfigNotFound, "Unable to determine home directory")
                }</span>
                <span class="cov1" title="1">configDir = filepath.Join(homeDir, ".config")</span>
        }

        // Check for YAML config
        <span class="cov1" title="1">yamlPath := filepath.Join(configDir, "taskopen", "config.yml")
        if fileExists(yamlPath) </span><span class="cov0" title="0">{
                return yamlPath, nil
        }</span>

        // Check for legacy INI config
        <span class="cov1" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, errors.ConfigNotFound, "Unable to determine home directory")
        }</span>

        <span class="cov1" title="1">legacyPath := filepath.Join(homeDir, ".taskopenrc")
        if fileExists(legacyPath) </span><span class="cov0" title="0">{
                return legacyPath, nil
        }</span>

        // Return preferred YAML path even if it doesn't exist
        <span class="cov1" title="1">return yamlPath, nil</span>
}

// Validate performs comprehensive validation on the configuration.
func (c *Config) Validate() error <span class="cov6" title="5">{
        var validationErrors []types.ValidationError

        // Validate general settings
        if strings.TrimSpace(c.General.Editor) == "" </span><span class="cov1" title="1">{
                validationErrors = append(validationErrors, types.ValidationError{
                        Field:   "general.editor",
                        Value:   c.General.Editor,
                        Message: "editor command is required",
                })
        }</span>

        <span class="cov6" title="5">if strings.TrimSpace(c.General.TaskBin) == "" </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, types.ValidationError{
                        Field:   "general.taskbin",
                        Value:   c.General.TaskBin,
                        Message: "taskwarrior binary path is required",
                })
        }</span>

        // Validate actions
        <span class="cov6" title="5">if len(c.Actions) == 0 </span><span class="cov1" title="1">{
                validationErrors = append(validationErrors, types.ValidationError{
                        Field:   "actions",
                        Value:   fmt.Sprintf("%d actions", len(c.Actions)),
                        Message: "at least one action must be defined",
                })
        }</span>

        <span class="cov6" title="5">actionNames := make(map[string]bool)
        for i, action := range c.Actions </span><span class="cov8" title="9">{
                // Check for duplicate action names
                if actionNames[action.Name] </span><span class="cov1" title="1">{
                        validationErrors = append(validationErrors, types.ValidationError{
                                Field:   fmt.Sprintf("actions[%d].name", i),
                                Value:   action.Name,
                                Message: "duplicate action name",
                        })
                }</span>
                <span class="cov8" title="9">actionNames[action.Name] = true

                // Validate individual action
                if err := action.Validate(); err != nil </span><span class="cov0" title="0">{
                        if actionValidationErrs, ok := err.(*types.ValidationErrors); ok </span><span class="cov0" title="0">{
                                for _, actionErr := range actionValidationErrs.Errors </span><span class="cov0" title="0">{
                                        validationErrors = append(validationErrors, types.ValidationError{
                                                Field:   fmt.Sprintf("actions[%d].%s", i, actionErr.Field),
                                                Value:   actionErr.Value,
                                                Message: actionErr.Message,
                                        })
                                }</span>
                        }
                }
        }

        // Validate CLI configuration
        <span class="cov6" title="5">if c.CLI.DefaultSubcommand == "" </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, types.ValidationError{
                        Field:   "cli.default_subcommand",
                        Value:   c.CLI.DefaultSubcommand,
                        Message: "default subcommand is required",
                })
        }</span>

        <span class="cov6" title="5">if len(validationErrors) &gt; 0 </span><span class="cov4" title="3">{
                return &amp;types.ValidationErrors{Errors: validationErrors}
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// GetAction returns an action by name.
func (c *Config) GetAction(name string) (*types.Action, bool) <span class="cov5" title="4">{
        for i := range c.Actions </span><span class="cov9" title="11">{
                if c.Actions[i].Name == name </span><span class="cov3" title="2">{
                        return &amp;c.Actions[i], true
                }</span>
        }
        <span class="cov3" title="2">return nil, false</span>
}

// GetActionNames returns all action names.
func (c *Config) GetActionNames() []string <span class="cov1" title="1">{
        names := make([]string, len(c.Actions))
        for i, action := range c.Actions </span><span class="cov4" title="3">{
                names[i] = action.Name
        }</span>
        <span class="cov1" title="1">return names</span>
}

// AddAction adds a new action to the configuration.
func (c *Config) AddAction(action types.Action) error <span class="cov3" title="2">{
        // Check for duplicate name
        if _, exists := c.GetAction(action.Name); exists </span><span class="cov1" title="1">{
                return errors.New(errors.ConfigInvalid, "Action with this name already exists").
                        WithDetails(fmt.Sprintf("Action name: %s", action.Name)).
                        WithSuggestion("Use a different action name")
        }</span>

        // Validate the action
        <span class="cov1" title="1">if err := action.Validate(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ValidationFailed, "Invalid action configuration")
        }</span>

        <span class="cov1" title="1">c.Actions = append(c.Actions, action)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package config - Interactive configuration generation
package config

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/types"
)

// GenerateInteractive creates a configuration interactively with user input.
func GenerateInteractive(configPath string) error <span class="cov0" title="0">{
        fmt.Println("üéØ Taskopen Configuration Setup")
        fmt.Println("===============================")
        fmt.Println()

        config := DefaultConfig()
        reader := bufio.NewReader(os.Stdin)

        // General configuration
        fmt.Println("üìù General Configuration")
        fmt.Println("------------------------")

        // Editor
        fmt.Printf("Editor command [%s]: ", config.General.Editor)
        if editor := readLine(reader); editor != "" </span><span class="cov0" title="0">{
                config.General.Editor = editor
        }</span>

        // Taskwarrior binary
        <span class="cov0" title="0">fmt.Printf("Taskwarrior binary [%s]: ", config.General.TaskBin)
        if taskBin := readLine(reader); taskBin != "" </span><span class="cov0" title="0">{
                config.General.TaskBin = taskBin
        }</span>

        // Task attributes
        <span class="cov0" title="0">fmt.Printf("Task attributes to display [%s]: ", config.General.TaskAttributes)
        if attrs := readLine(reader); attrs != "" </span><span class="cov0" title="0">{
                config.General.TaskAttributes = attrs
        }</span>

        // Debug mode
        <span class="cov0" title="0">fmt.Print("Enable debug mode? [y/N]: ")
        if debug := readLine(reader); strings.ToLower(debug) == "y" </span><span class="cov0" title="0">{
                config.General.Debug = true
        }</span>

        <span class="cov0" title="0">fmt.Println()

        // Actions configuration
        fmt.Println("‚ö° Actions Configuration")
        fmt.Println("------------------------")
        fmt.Println("Default actions include:")
        for _, action := range config.Actions </span><span class="cov0" title="0">{
                fmt.Printf("  ‚Ä¢ %s: %s\n", action.Name, action.Command)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        fmt.Print("Add custom actions? [y/N]: ")
        if addActions := readLine(reader); strings.ToLower(addActions) == "y" </span><span class="cov0" title="0">{
                if err := configureActionsInteractively(config, reader); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">fmt.Println()

        // CLI configuration
        fmt.Println("üñ•Ô∏è  CLI Configuration")
        fmt.Println("---------------------")

        fmt.Printf("Default subcommand [%s]: ", config.CLI.DefaultSubcommand)
        if defaultCmd := readLine(reader); defaultCmd != "" </span><span class="cov0" title="0">{
                config.CLI.DefaultSubcommand = defaultCmd
        }</span>

        <span class="cov0" title="0">fmt.Println()

        // Summary and confirmation
        fmt.Println("üìã Configuration Summary")
        fmt.Println("------------------------")
        fmt.Printf("‚Ä¢ Editor: %s\n", config.General.Editor)
        fmt.Printf("‚Ä¢ Taskwarrior: %s\n", config.General.TaskBin)
        fmt.Printf("‚Ä¢ Actions: %d defined\n", len(config.Actions))
        fmt.Printf("‚Ä¢ Debug mode: %v\n", config.General.Debug)
        fmt.Printf("‚Ä¢ Config path: %s\n", configPath)
        fmt.Println()

        fmt.Print("Save this configuration? [Y/n]: ")
        if confirm := readLine(reader); confirm != "" &amp;&amp; strings.ToLower(confirm) != "y" </span><span class="cov0" title="0">{
                return errors.New(errors.ConfigInvalid, "Configuration not saved")
        }</span>

        // Save configuration
        <span class="cov0" title="0">if err := Save(config, configPath); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ConfigInvalid, "Failed to save configuration")
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Printf("‚úÖ Configuration saved successfully to: %s\n", configPath)
        fmt.Println()
        fmt.Println("Next steps:")
        fmt.Println("‚Ä¢ Run 'taskopen diagnostics' to verify setup")
        fmt.Println("‚Ä¢ Run 'taskopen' to start using taskopen")
        fmt.Println("‚Ä¢ Edit the config file to add more custom actions")

        return nil</span>
}

// configureActionsInteractively allows user to add custom actions.
func configureActionsInteractively(config *Config, reader *bufio.Reader) error <span class="cov0" title="0">{
        fmt.Println()
        fmt.Println("Adding custom actions...")
        fmt.Println("Leave action name empty to finish.")
        fmt.Println()

        for </span><span class="cov0" title="0">{
                fmt.Print("Action name: ")
                name := readLine(reader)
                if name == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                // Check for duplicate names
                <span class="cov0" title="0">if _, exists := config.GetAction(name); exists </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Action '%s' already exists. Choose a different name.\n", name)
                        continue</span>
                }

                <span class="cov0" title="0">action := types.Action{
                        Name:       name,
                        Target:     "annotations",
                        LabelRegex: ".*",
                        Modes:      []string{"batch", "any", "normal"},
                }

                fmt.Print("Target (annotations/description) [annotations]: ")
                if target := readLine(reader); target != "" </span><span class="cov0" title="0">{
                        action.Target = target
                }</span>

                <span class="cov0" title="0">fmt.Print("Regex pattern [.*]: ")
                if regex := readLine(reader); regex != "" </span><span class="cov0" title="0">{
                        action.Regex = regex
                }</span> else<span class="cov0" title="0"> {
                        action.Regex = ".*"
                }</span>

                <span class="cov0" title="0">fmt.Print("Command to execute: ")
                command := readLine(reader)
                if command == "" </span><span class="cov0" title="0">{
                        fmt.Println("Command is required. Skipping this action.")
                        continue</span>
                }
                <span class="cov0" title="0">action.Command = command

                fmt.Print("Modes (comma-separated) [batch,any,normal]: ")
                if modes := readLine(reader); modes != "" </span><span class="cov0" title="0">{
                        action.Modes = strings.Split(modes, ",")
                        for i := range action.Modes </span><span class="cov0" title="0">{
                                action.Modes[i] = strings.TrimSpace(action.Modes[i])
                        }</span>
                }

                // Validate the action
                <span class="cov0" title="0">if err := action.Validate(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  Invalid action: %v\n", err)
                        fmt.Println("Skipping this action.")
                        continue</span>
                }

                <span class="cov0" title="0">config.Actions = append(config.Actions, action)
                fmt.Printf("‚úÖ Added action '%s'\n", name)
                fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// readLine reads a line from the reader, trimming whitespace.
func readLine(reader *bufio.Reader) string <span class="cov0" title="0">{
        line, _ := reader.ReadString('\n')
        return strings.TrimSpace(line)
}</span>

// ShowConfigExample displays an example configuration file.
func ShowConfigExample() <span class="cov0" title="0">{
        example := `# Example Taskopen Configuration (YAML)
general:
  editor: "vim"
  taskbin: "task"
  taskargs: []
  task_attributes: "priority,project,tags,description"
  no_annotation_hook: "addnote $ID"
  sort: "urgency-,annot"
  base_filter: "+PENDING"
  debug: false

actions:
  - name: "files"
    target: "annotations"
    regex: '^[\.\/~]+.*\.(.*)'
    labelregex: ".*"
    command: "xdg-open $FILE"
    modes: ["batch", "any", "normal"]
    
  - name: "notes"
    target: "annotations"
    regex: '^Notes(\..*)?'
    labelregex: ".*"
    command: 'editnote ~/Notes/tasknotes/$UUID$LAST_MATCH "$TASK_DESCRIPTION" $UUID'
    modes: ["batch", "any", "normal"]
    
  - name: "url"
    target: "annotations"
    regex: '((?:www|http).*)'
    labelregex: ".*"
    command: "xdg-open $LAST_MATCH"
    modes: ["batch", "any", "normal"]
    
  - name: "custom-editor"
    target: "description"
    regex: "EDIT"
    labelregex: ".*"
    command: "$EDITOR /tmp/task-$UUID.txt"
    modes: ["normal"]

cli:
  default_subcommand: "normal"
  aliases:
    batch: ""
    any: ""
    normal: ""
  groups: {}

config_version: "2.0"`

        fmt.Println("Example Configuration:")
        fmt.Println("=====================")
        fmt.Println(example)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package config - YAML configuration loading and parsing
package config

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
)

// Load reads and parses the configuration from the specified path.
func Load(configPath string) (*Config, error) <span class="cov0" title="0">{
        // Check if config file exists
        if !fileExists(configPath) </span><span class="cov0" title="0">{
                return nil, errors.ConfigNotFoundError(configPath)
        }</span>

        // Read the config file
        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.ConfigNotFound, "Failed to read configuration file").
                        WithDetails(fmt.Sprintf("Path: %s", configPath)).
                        WithSuggestion("Check file permissions and path")
        }</span>

        // Parse YAML
        <span class="cov0" title="0">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.ConfigInvalid, "Invalid YAML configuration").
                        WithDetails(fmt.Sprintf("Parse error: %v", err)).
                        WithSuggestions([]string{
                                "Check YAML syntax",
                                "Validate indentation",
                                "Ensure proper field names",
                                "Run 'taskopen config validate' for detailed validation",
                        })
        }</span>

        // Set the config path for reference
        <span class="cov0" title="0">config.ConfigPath = configPath

        // Validate the configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.ConfigInvalid, "Configuration validation failed").
                        WithSuggestions([]string{
                                "Check required fields",
                                "Verify action definitions",
                                "Run 'taskopen config init' to create a new config",
                        })
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// LoadOrCreate attempts to load configuration, creating default if not found.
func LoadOrCreate(configPath string) (*Config, error) <span class="cov0" title="0">{
        // Try to load existing configuration
        config, err := Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                // If config not found, create default
                if errors.IsType(err, errors.ConfigNotFound) </span><span class="cov0" title="0">{
                        config = DefaultConfig()
                        config.ConfigPath = configPath

                        // Ask user if they want to create the config
                        if err := createConfigInteractively(configPath, config); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return config, nil</span>
                }
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return config, nil</span>
}

// Save writes the configuration to the specified path.
func Save(config *Config, configPath string) error <span class="cov0" title="0">{
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.PermissionDenied, "Cannot create config directory").
                        WithDetails(fmt.Sprintf("Path: %s", filepath.Dir(configPath)))
        }</span>

        // Marshal to YAML
        <span class="cov0" title="0">data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.InternalError, "Failed to serialize configuration")
        }</span>

        // Write to file
        <span class="cov0" title="0">if err := os.WriteFile(configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.PermissionDenied, "Cannot write configuration file").
                        WithDetails(fmt.Sprintf("Path: %s", configPath))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createConfigInteractively prompts user to create configuration.
func createConfigInteractively(configPath string, config *Config) error <span class="cov0" title="0">{
        fmt.Printf("Configuration file '%s' does not exist.\n", configPath)
        fmt.Print("Create default configuration? [Y/n]: ")

        var answer string
        fmt.Scanln(&amp;answer)

        // Default to yes if no answer provided
        if answer == "" || answer == "y" || answer == "Y" </span><span class="cov0" title="0">{
                if err := Save(config, configPath); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, errors.ConfigNotFound, "Failed to create default configuration")
                }</span>
                <span class="cov0" title="0">fmt.Printf("‚úì Created default configuration at: %s\n", configPath)
                return nil</span>
        }

        <span class="cov0" title="0">return errors.New(errors.ConfigNotFound, "Configuration file required").
                WithSuggestion("Run 'taskopen config init' to create configuration interactively")</span>
}

// Validate validates a configuration file without loading it.
func ValidateFile(configPath string) error <span class="cov0" title="0">{
        config, err := Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úì Configuration is valid: %s\n", configPath)
        fmt.Printf("  - %d actions defined\n", len(config.Actions))
        fmt.Printf("  - Editor: %s\n", config.General.Editor)
        fmt.Printf("  - Task binary: %s\n", config.General.TaskBin)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package config - INI to YAML migration functionality
package config

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/types"
)

// MigrateFromINI converts an INI configuration file to YAML format.
func MigrateFromINI(iniPath, yamlPath string) error <span class="cov0" title="0">{
        // Check if INI file exists
        if !fileExists(iniPath) </span><span class="cov0" title="0">{
                return errors.New(errors.ConfigNotFound, "INI configuration file not found").
                        WithDetails(fmt.Sprintf("Path: %s", iniPath)).
                        WithSuggestion("Verify the INI config file path")
        }</span>

        // Parse INI configuration
        <span class="cov0" title="0">config, err := parseINIConfig(iniPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ConfigInvalid, "Failed to parse INI configuration").
                        WithSuggestions([]string{
                                "Check INI file syntax",
                                "Ensure file is readable",
                        })
        }</span>

        // Ensure YAML directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(yamlPath), 0755); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.PermissionDenied, "Cannot create YAML config directory").
                        WithDetails(fmt.Sprintf("Directory: %s", filepath.Dir(yamlPath)))
        }</span>

        // Save as YAML
        <span class="cov0" title="0">if err := Save(config, yamlPath); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ConfigInvalid, "Failed to save YAML configuration").
                        WithDetails(fmt.Sprintf("Target path: %s", yamlPath))
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úì Successfully migrated configuration:\n")
        fmt.Printf("  From: %s\n", iniPath)
        fmt.Printf("  To:   %s\n", yamlPath)
        fmt.Printf("  Actions migrated: %d\n", len(config.Actions))

        return nil</span>
}

// parseINIConfig parses an INI file and returns a Config struct.
func parseINIConfig(iniPath string) (*Config, error) <span class="cov0" title="0">{
        file, err := os.Open(iniPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        config := DefaultConfig()
        config.Actions = []types.Action{} // Start with empty actions, we'll add them from INI

        scanner := bufio.NewScanner(file)
        currentSection := ""
        actionRegex := regexp.MustCompile(`^(.+)\.(target|regex|labelregex|command|modes|filtercommand|inlinecommand)$`)
        aliasGroupRegex := regexp.MustCompile(`^(alias|group)\.([^\.]+)$`)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                // Skip comments and empty lines
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, ";") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Section headers
                <span class="cov0" title="0">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov0" title="0">{
                        currentSection = strings.ToLower(strings.Trim(line, "[]"))
                        continue</span>
                }

                // Key-value pairs
                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch currentSection </span>{
                case "general":<span class="cov0" title="0">
                        parseGeneralSection(config, key, value)</span>
                case "actions":<span class="cov0" title="0">
                        parseActionsSection(config, key, value, actionRegex)</span>
                case "cli":<span class="cov0" title="0">
                        parseCLISection(config, key, value, aliasGroupRegex)</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure we have at least the default actions if none were defined
        <span class="cov0" title="0">if len(config.Actions) == 0 </span><span class="cov0" title="0">{
                config.Actions = DefaultConfig().Actions
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// parseGeneralSection parses the [General] section of INI config.
func parseGeneralSection(config *Config, key, value string) <span class="cov0" title="0">{
        switch strings.ToLower(key) </span>{
        case "editor":<span class="cov0" title="0">
                config.General.Editor = value</span>
        case "taskbin":<span class="cov0" title="0">
                config.General.TaskBin = value</span>
        case "taskargs":<span class="cov0" title="0">
                config.General.TaskArgs = strings.Fields(value)</span>
        case "path_ext":<span class="cov0" title="0">
                config.General.PathExt = value</span>
        case "task_attributes":<span class="cov0" title="0">
                config.General.TaskAttributes = value</span>
        case "no_annotation_hook":<span class="cov0" title="0">
                config.General.NoAnnotationHook = value</span>
        case "--sort":<span class="cov0" title="0">
                config.General.Sort = value</span>
        case "--active-tasks":<span class="cov0" title="0">
                config.General.BaseFilter = value</span>
        case "--debug":<span class="cov0" title="0">
                config.General.Debug = strings.ToLower(value) == "on" || strings.ToLower(value) == "true"</span>
        }
}

// parseActionsSection parses the [Actions] section of INI config.
func parseActionsSection(config *Config, key, value string, actionRegex *regexp.Regexp) <span class="cov0" title="0">{
        if matches := actionRegex.FindStringSubmatch(key); matches != nil </span><span class="cov0" title="0">{
                actionName := matches[1]
                field := matches[2]

                // Find or create action
                var action *types.Action
                for i := range config.Actions </span><span class="cov0" title="0">{
                        if config.Actions[i].Name == actionName </span><span class="cov0" title="0">{
                                action = &amp;config.Actions[i]
                                break</span>
                        }
                }

                <span class="cov0" title="0">if action == nil </span><span class="cov0" title="0">{
                        // Create new action with defaults
                        newAction := types.Action{
                                Name:       actionName,
                                Target:     "annotations",
                                LabelRegex: ".*",
                                Regex:      ".*",
                                Modes:      []string{"batch", "any", "normal"},
                        }
                        config.Actions = append(config.Actions, newAction)
                        action = &amp;config.Actions[len(config.Actions)-1]
                }</span>

                // Set the field value
                <span class="cov0" title="0">switch field </span>{
                case "target":<span class="cov0" title="0">
                        action.Target = value</span>
                case "regex":<span class="cov0" title="0">
                        action.Regex = value</span>
                case "labelregex":<span class="cov0" title="0">
                        action.LabelRegex = value</span>
                case "command":<span class="cov0" title="0">
                        action.Command = value</span>
                case "modes":<span class="cov0" title="0">
                        action.Modes = strings.Split(value, ",")
                        for i := range action.Modes </span><span class="cov0" title="0">{
                                action.Modes[i] = strings.TrimSpace(action.Modes[i])
                        }</span>
                case "filtercommand":<span class="cov0" title="0">
                        action.FilterCommand = value</span>
                case "inlinecommand":<span class="cov0" title="0">
                        action.InlineCommand = value</span>
                }
        }
}

// parseCLISection parses the [CLI] section of INI config.
func parseCLISection(config *Config, key, value string, aliasGroupRegex *regexp.Regexp) <span class="cov0" title="0">{
        if key == "default" </span><span class="cov0" title="0">{
                config.CLI.DefaultSubcommand = value
        }</span> else<span class="cov0" title="0"> if matches := aliasGroupRegex.FindStringSubmatch(key); matches != nil </span><span class="cov0" title="0">{
                category := matches[1]
                name := matches[2]

                switch category </span>{
                case "alias":<span class="cov0" title="0">
                        if config.CLI.Aliases == nil </span><span class="cov0" title="0">{
                                config.CLI.Aliases = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">config.CLI.Aliases[name] = value</span>
                case "group":<span class="cov0" title="0">
                        if config.CLI.Groups == nil </span><span class="cov0" title="0">{
                                config.CLI.Groups = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">config.CLI.Groups[name] = value</span>
                }
        }
}

// BackupINI creates a backup of the INI file before migration.
func BackupINI(iniPath string) (string, error) <span class="cov0" title="0">{
        backupPath := iniPath + ".backup"

        // Read original file
        data, err := os.ReadFile(iniPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Write backup
        <span class="cov0" title="0">if err := os.WriteFile(backupPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return backupPath, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package config - JSON Schema generation for IDE support
package config

import (
        "encoding/json"
        "fmt"
        "os"
)

// JSONSchema generates a JSON schema for the taskopen configuration.
func GenerateJSONSchema() ([]byte, error) <span class="cov0" title="0">{
        schema := map[string]interface{}{
                "$schema":              "http://json-schema.org/draft-07/schema#",
                "title":                "Taskopen Configuration",
                "description":          "Configuration schema for taskopen task annotation opener",
                "type":                 "object",
                "additionalProperties": false,

                "properties": map[string]interface{}{
                        "config_version": map[string]interface{}{
                                "type":        "string",
                                "description": "Configuration format version",
                                "default":     "2.0",
                        },

                        "general": map[string]interface{}{
                                "type":                 "object",
                                "description":          "General taskopen settings",
                                "required":             []string{"editor", "taskbin"},
                                "additionalProperties": false,

                                "properties": map[string]interface{}{
                                        "editor": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Editor command for editing notes and files",
                                                "default":     "vim",
                                                "examples":    []string{"vim", "nano", "code", "emacs"},
                                        },

                                        "taskbin": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Path to taskwarrior binary",
                                                "default":     "task",
                                                "examples":    []string{"task", "/usr/bin/task", "/usr/local/bin/task"},
                                        },

                                        "taskargs": map[string]interface{}{
                                                "type":        "array",
                                                "description": "Additional arguments to pass to taskwarrior",
                                                "items": map[string]interface{}{
                                                        "type": "string",
                                                },
                                                "default": []interface{}{},
                                        },

                                        "path_ext": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Path extension for file operations",
                                                "default":     "",
                                        },

                                        "task_attributes": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Task attributes to display in output",
                                                "default":     "priority,project,tags,description",
                                                "examples": []string{
                                                        "priority,project,tags,description",
                                                        "urgency,project,description",
                                                        "id,description,due",
                                                },
                                        },

                                        "no_annotation_hook": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Command to run for tasks without annotations",
                                                "default":     "addnote $ID",
                                        },

                                        "sort": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Default task sort order",
                                                "default":     "urgency-,annot",
                                                "examples":    []string{"urgency-", "due+", "priority-,urgency-"},
                                        },

                                        "base_filter": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Base filter for task queries",
                                                "default":     "+PENDING",
                                                "examples":    []string{"+PENDING", "+READY", "status:pending"},
                                        },

                                        "debug": map[string]interface{}{
                                                "type":        "boolean",
                                                "description": "Enable debug output",
                                                "default":     false,
                                        },
                                },
                        },

                        "actions": map[string]interface{}{
                                "type":        "array",
                                "description": "Action definitions for opening task annotations",
                                "minItems":    1,

                                "items": map[string]interface{}{
                                        "type":                 "object",
                                        "description":          "A single action configuration",
                                        "required":             []string{"name", "target", "command"},
                                        "additionalProperties": false,

                                        "properties": map[string]interface{}{
                                                "name": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Unique name for this action",
                                                        "minLength":   1,
                                                        "pattern":     "^[a-zA-Z][a-zA-Z0-9_-]*$",
                                                },

                                                "target": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Where to look for matches",
                                                        "enum":        []string{"annotations", "description"},
                                                        "default":     "annotations",
                                                },

                                                "regex": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Regular expression pattern to match",
                                                        "default":     ".*",
                                                },

                                                "labelregex": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Regular expression for annotation labels",
                                                        "default":     ".*",
                                                },

                                                "command": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Command to execute when action matches",
                                                        "minLength":   1,
                                                },

                                                "modes": map[string]interface{}{
                                                        "type":        "array",
                                                        "description": "Modes in which this action is available",
                                                        "items": map[string]interface{}{
                                                                "type": "string",
                                                                "enum": []string{"batch", "any", "normal"},
                                                        },
                                                        "default":     []interface{}{"batch", "any", "normal"},
                                                        "minItems":    1,
                                                        "uniqueItems": true,
                                                },

                                                "filtercommand": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Command to filter matches before execution",
                                                        "default":     "",
                                                },

                                                "inlinecommand": map[string]interface{}{
                                                        "type":        "string",
                                                        "description": "Command to execute inline with task display",
                                                        "default":     "",
                                                },
                                        },
                                },
                        },

                        "cli": map[string]interface{}{
                                "type":                 "object",
                                "description":          "CLI-specific configuration",
                                "additionalProperties": false,

                                "properties": map[string]interface{}{
                                        "default_subcommand": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Default subcommand when none specified",
                                                "default":     "normal",
                                                "enum":        []string{"batch", "any", "normal"},
                                        },

                                        "aliases": map[string]interface{}{
                                                "type":        "object",
                                                "description": "Command aliases",
                                                "additionalProperties": map[string]interface{}{
                                                        "type": "string",
                                                },
                                        },

                                        "groups": map[string]interface{}{
                                                "type":        "object",
                                                "description": "Action groups",
                                                "additionalProperties": map[string]interface{}{
                                                        "type": "string",
                                                },
                                        },
                                },
                        },
                },

                "required": []string{"general", "actions"},
        }

        return json.MarshalIndent(schema, "", "  ")
}</span>

// SaveJSONSchema saves the JSON schema to a file.
func SaveJSONSchema(filePath string) error <span class="cov0" title="0">{
        schema, err := GenerateJSONSchema()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate JSON schema: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filePath, schema, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write JSON schema: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSchemaExamples returns example configurations for documentation.
func GetSchemaExamples() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "minimal": map[string]interface{}{
                        "general": map[string]interface{}{
                                "editor":  "vim",
                                "taskbin": "task",
                        },
                        "actions": []map[string]interface{}{
                                {
                                        "name":    "files",
                                        "target":  "annotations",
                                        "regex":   `^[\.\/~]+.*\.(.*)",`,
                                        "command": "xdg-open $FILE",
                                },
                        },
                },

                "comprehensive": map[string]interface{}{
                        "config_version": "2.0",
                        "general": map[string]interface{}{
                                "editor":             "code",
                                "taskbin":            "task",
                                "taskargs":           []string{"rc.verbose=off"},
                                "task_attributes":    "priority,project,tags,description,due",
                                "no_annotation_hook": "addnote $ID",
                                "sort":               "urgency-,annot",
                                "base_filter":        "+PENDING",
                                "debug":              false,
                        },
                        "actions": []map[string]interface{}{
                                {
                                        "name":       "files",
                                        "target":     "annotations",
                                        "regex":      `^[\.\/~]+.*\.(.*)",`,
                                        "labelregex": ".*",
                                        "command":    "xdg-open $FILE",
                                        "modes":      []string{"batch", "any", "normal"},
                                },
                                {
                                        "name":          "edit-task",
                                        "target":        "description",
                                        "regex":         "EDIT",
                                        "command":       "$EDITOR /tmp/task-$UUID.txt",
                                        "modes":         []string{"normal"},
                                        "filtercommand": "test -w /tmp",
                                },
                        },
                        "cli": map[string]interface{}{
                                "default_subcommand": "normal",
                                "aliases": map[string]interface{}{
                                        "b": "batch",
                                        "n": "normal",
                                },
                                "groups": map[string]interface{}{
                                        "files": "files,notes",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package core provides the main integration layer combining configuration, execution, and taskwarrior.
package core

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/config"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/exec"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/taskwarrior"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/types"
)

// TaskOpen provides the main application functionality.
type TaskOpen struct {
        config     *config.Config
        executor   *exec.Executor
        taskClient *taskwarrior.Client
}

// New creates a new TaskOpen instance.
func New(cfg *config.Config) (*TaskOpen, error) <span class="cov8" title="10">{
        if cfg == nil </span><span class="cov1" title="1">{
                return nil, errors.New(errors.ConfigInvalid, "Configuration is required")
        }</span>

        // Validate configuration
        <span class="cov8" title="9">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.ConfigInvalid, "Invalid configuration")
        }</span>

        // Create executor with reasonable defaults
        <span class="cov8" title="9">execOptions := exec.ExecutionOptions{
                Timeout:       30 * time.Second,
                CaptureOutput: true,
                Retry: exec.RetryOptions{
                        MaxAttempts:       2,
                        BaseDelay:         200 * time.Millisecond,
                        MaxDelay:          2 * time.Second,
                        BackoffMultiplier: 1.5,
                },
                Sandbox: exec.SandboxOptions{
                        MaxMemoryMB: 256,
                },
        }

        executor := exec.New(execOptions)

        // Create taskwarrior client
        taskClient := taskwarrior.NewClient(
                cfg.General.TaskBin,
                cfg.General.TaskArgs,
                30*time.Second,
        )

        return &amp;TaskOpen{
                config:     cfg,
                executor:   executor,
                taskClient: taskClient,
        }, nil</span>
}

// VerifySetup checks that all required components are available and functional.
func (to *TaskOpen) VerifySetup(ctx context.Context) error <span class="cov1" title="1">{
        // Check taskwarrior availability
        if err := taskwarrior.CheckTaskwarrior(ctx, to.config.General.TaskBin); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check editor availability if needed
        <span class="cov1" title="1">if to.config.General.Editor != "" </span><span class="cov1" title="1">{
                editorParts := strings.Fields(to.config.General.Editor)
                if len(editorParts) &gt; 0 </span><span class="cov1" title="1">{
                        _, err := to.executor.ExecuteFilter(ctx, "command", []string{"-v", editorParts[0]}, nil)
                        if err != nil </span><span class="cov1" title="1">{
                                return errors.New(errors.ActionExecution, "Editor not found").
                                        WithDetails(fmt.Sprintf("Editor: %s", to.config.General.Editor)).
                                        WithSuggestions([]string{
                                                "Install the editor or update the configuration",
                                                "Check that the editor is in your PATH",
                                                "Run 'taskopen config init' to reconfigure",
                                        })
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetTasks retrieves tasks based on filters.
func (to *TaskOpen) GetTasks(ctx context.Context, filters []string) ([]taskwarrior.Task, error) <span class="cov0" title="0">{
        // Add base filter from configuration
        if to.config.General.BaseFilter != "" </span><span class="cov0" title="0">{
                filters = append([]string{to.config.General.BaseFilter}, filters...)
        }</span>

        <span class="cov0" title="0">return to.taskClient.Query(ctx, filters)</span>
}

// GetTasksStream retrieves tasks using streaming for large datasets.
func (to *TaskOpen) GetTasksStream(ctx context.Context, filters []string) (&lt;-chan taskwarrior.Task, &lt;-chan error) <span class="cov0" title="0">{
        // Add base filter from configuration
        if to.config.General.BaseFilter != "" </span><span class="cov0" title="0">{
                filters = append([]string{to.config.General.BaseFilter}, filters...)
        }</span>

        <span class="cov0" title="0">return to.taskClient.ExportStream(ctx, filters)</span>
}

// FindActionables identifies actionable items from tasks based on configured actions.
func (to *TaskOpen) FindActionables(ctx context.Context, tasks []taskwarrior.Task) ([]types.Actionable, error) <span class="cov0" title="0">{
        var actionables []types.Actionable

        for _, task := range tasks </span><span class="cov0" title="0">{
                // Check each configured action
                for _, action := range to.config.Actions </span><span class="cov0" title="0">{
                        taskActionables, err := to.findActionablesForTask(task, action)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, errors.ActionInvalid, "Failed to process task").
                                        WithDetails(fmt.Sprintf("Task UUID: %s, Action: %s", task.UUID, action.Name))
                        }</span>

                        <span class="cov0" title="0">actionables = append(actionables, taskActionables...)</span>
                }
        }

        <span class="cov0" title="0">return actionables, nil</span>
}

// findActionablesForTask finds actionables for a specific task and action.
func (to *TaskOpen) findActionablesForTask(task taskwarrior.Task, action types.Action) ([]types.Actionable, error) <span class="cov5" title="4">{
        var actionables []types.Actionable

        // Compile regex patterns
        regex, err := regexp.Compile(action.Regex)
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.New(errors.ValidationFailed, "Invalid action regex").
                        WithDetails(fmt.Sprintf("Action: %s, Regex: %s", action.Name, action.Regex))
        }</span>

        <span class="cov4" title="3">var labelRegex *regexp.Regexp
        if action.LabelRegex != "" &amp;&amp; action.LabelRegex != ".*" </span><span class="cov0" title="0">{
                labelRegex, err = regexp.Compile(action.LabelRegex)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(errors.ValidationFailed, "Invalid action label regex").
                                WithDetails(fmt.Sprintf("Action: %s, LabelRegex: %s", action.Name, action.LabelRegex))
                }</span>
        }

        // Check target - annotations or description
        <span class="cov4" title="3">switch strings.ToLower(action.Target) </span>{
        case "annotations":<span class="cov1" title="1">
                for _, annotation := range task.Annotations </span><span class="cov3" title="2">{
                        if regex.MatchString(annotation.Description) </span><span class="cov1" title="1">{
                                // Check label regex if specified
                                if labelRegex == nil || labelRegex.MatchString(annotation.Description) </span><span class="cov1" title="1">{
                                        actionable, err := to.createActionable(task, action, annotation.Description, annotation.Description)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov1" title="1">actionables = append(actionables, actionable)</span>
                                }
                        }
                }

        case "description":<span class="cov1" title="1">
                if regex.MatchString(task.Description) </span><span class="cov1" title="1">{
                        // Check label regex if specified
                        if labelRegex == nil || labelRegex.MatchString(task.Description) </span><span class="cov1" title="1">{
                                actionable, err := to.createActionable(task, action, task.Description, task.Description)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov1" title="1">actionables = append(actionables, actionable)</span>
                        }
                }

        default:<span class="cov1" title="1">
                return nil, errors.New(errors.ActionInvalid, "Invalid action target").
                        WithDetails(fmt.Sprintf("Target: %s, valid values: annotations, description", action.Target))</span>
        }

        <span class="cov3" title="2">return actionables, nil</span>
}

// createActionable creates an actionable from a task, action, and matched text.
func (to *TaskOpen) createActionable(task taskwarrior.Task, action types.Action, text, entry string) (types.Actionable, error) <span class="cov4" title="3">{
        // Serialize task to JSON for the actionable
        taskJSON, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                return types.Actionable{}, errors.Wrap(err, errors.InternalError, "Failed to serialize task")
        }</span>

        // Build environment variables for command execution
        <span class="cov4" title="3">env := to.buildEnvironment(task, action, text)

        actionable := types.Actionable{
                Text:   text,
                Task:   json.RawMessage(taskJSON),
                Entry:  entry,
                Action: action,
                Env:    env,
        }

        return actionable, nil</span>
}

// buildEnvironment creates environment variables for action execution.
func (to *TaskOpen) buildEnvironment(task taskwarrior.Task, action types.Action, matchedText string) map[string]string <span class="cov5" title="4">{
        env := make(map[string]string)

        // Task-specific variables
        env["TASK_ID"] = fmt.Sprintf("%d", task.ID)
        env["TASK_UUID"] = task.UUID
        env["TASK_DESCRIPTION"] = task.Description
        env["TASK_STATUS"] = task.Status
        env["TASK_PROJECT"] = task.Project
        env["TASK_PRIORITY"] = task.Priority

        if len(task.Tags) &gt; 0 </span><span class="cov1" title="1">{
                env["TASK_TAGS"] = strings.Join(task.Tags, ",")
        }</span>

        <span class="cov5" title="4">if task.Due != nil </span><span class="cov0" title="0">{
                env["TASK_DUE"] = task.Due.Format(time.RFC3339)
        }</span>

        // Action-specific variables
        <span class="cov5" title="4">env["ACTION_NAME"] = action.Name
        env["ACTION_TARGET"] = action.Target
        env["MATCHED_TEXT"] = matchedText

        // Find regex matches
        if action.Regex != "" </span><span class="cov5" title="4">{
                regex, err := regexp.Compile(action.Regex)
                if err == nil </span><span class="cov5" title="4">{
                        matches := regex.FindStringSubmatch(matchedText)
                        if len(matches) &gt; 1 </span><span class="cov1" title="1">{
                                env["LAST_MATCH"] = matches[len(matches)-1]

                                // Add numbered match groups
                                for i, match := range matches[1:] </span><span class="cov1" title="1">{
                                        env[fmt.Sprintf("MATCH_%d", i+1)] = match
                                }</span>
                        }
                }
        }

        // File-related variables (if applicable)
        <span class="cov5" title="4">if strings.Contains(matchedText, "/") || strings.Contains(matchedText, "\\") </span><span class="cov3" title="2">{
                env["FILE"] = matchedText
        }</span>

        // System variables
        <span class="cov5" title="4">env["EDITOR"] = to.config.General.Editor
        env["TASKOPEN_CONFIG"] = to.config.ConfigPath

        return env</span>
}

// ExecuteAction executes an actionable with the configured action.
func (to *TaskOpen) ExecuteAction(ctx context.Context, actionable types.Actionable) error <span class="cov0" title="0">{
        action := actionable.Action

        // Choose the appropriate execution method
        var err error

        switch </span>{
        case action.FilterCommand != "":<span class="cov0" title="0">
                // Execute filter command first
                success, filterErr := to.executeFilterCommand(ctx, action.FilterCommand, actionable.Env)
                if filterErr != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(filterErr, errors.ActionExecution, "Filter command failed")
                }</span>
                <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                        return errors.New(errors.ActionExecution, "Filter command returned false").
                                WithDetails(fmt.Sprintf("Filter: %s", action.FilterCommand)).
                                WithSuggestion("Check filter command logic and requirements")
                }</span>

                // Execute main command
                <span class="cov0" title="0">err = to.executeMainCommand(ctx, action.Command, actionable.Env)</span>

        case action.InlineCommand != "":<span class="cov0" title="0">
                // Execute inline command (non-interactive)
                err = to.executeInlineCommand(ctx, action.InlineCommand, actionable.Env)</span>

        default:<span class="cov0" title="0">
                // Execute main command
                err = to.executeMainCommand(ctx, action.Command, actionable.Env)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.ActionExecutionError(action.Name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// executeFilterCommand executes a filter command and returns success status.
func (to *TaskOpen) executeFilterCommand(ctx context.Context, command string, env map[string]string) (bool, error) <span class="cov0" title="0">{
        // Expand environment variables in command
        expandedCommand := to.expandCommand(command, env)

        // Parse command and arguments
        parts := strings.Fields(expandedCommand)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return false, errors.New(errors.ActionInvalid, "Empty filter command")
        }</span>

        <span class="cov0" title="0">result, err := to.executor.Execute(ctx, parts[0], parts[1:], &amp;exec.ExecutionOptions{
                Environment: env,
                Timeout:     10 * time.Second, // Shorter timeout for filters
        })

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return result.ExitCode == 0, nil</span>
}

// executeMainCommand executes the main action command.
func (to *TaskOpen) executeMainCommand(ctx context.Context, command string, env map[string]string) error <span class="cov0" title="0">{
        // Expand environment variables in command
        expandedCommand := to.expandCommand(command, env)

        // Parse command and arguments
        parts := strings.Fields(expandedCommand)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return errors.New(errors.ActionInvalid, "Empty command")
        }</span>

        <span class="cov0" title="0">_, err := to.executor.Execute(ctx, parts[0], parts[1:], &amp;exec.ExecutionOptions{
                Environment: env,
                Timeout:     60 * time.Second, // Longer timeout for main commands
        })

        return err</span>
}

// executeInlineCommand executes an inline command and captures output.
func (to *TaskOpen) executeInlineCommand(ctx context.Context, command string, env map[string]string) error <span class="cov0" title="0">{
        // Expand environment variables in command
        expandedCommand := to.expandCommand(command, env)

        // Parse command and arguments
        parts := strings.Fields(expandedCommand)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return errors.New(errors.ActionInvalid, "Empty inline command")
        }</span>

        <span class="cov0" title="0">result, err := to.executor.Execute(ctx, parts[0], parts[1:], &amp;exec.ExecutionOptions{
                Environment:   env,
                CaptureOutput: true,
                Timeout:       30 * time.Second,
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                return errors.New(errors.ActionExecution, "Inline command failed").
                        WithDetails(fmt.Sprintf("Exit code: %d, stderr: %s", result.ExitCode, result.Stderr))
        }</span>

        // Output could be used for further processing
        // For now, we just ensure the command succeeded
        <span class="cov0" title="0">return nil</span>
}

// expandCommand expands environment variables in a command string.
func (to *TaskOpen) expandCommand(command string, env map[string]string) string <span class="cov5" title="4">{
        result := command

        // Replace environment variables
        for key, value := range env </span><span class="cov10" title="16">{
                placeholder := fmt.Sprintf("$%s", key)
                result = strings.ReplaceAll(result, placeholder, value)

                // Also support ${VAR} syntax
                placeholder = fmt.Sprintf("${%s}", key)
                result = strings.ReplaceAll(result, placeholder, value)
        }</span>

        <span class="cov5" title="4">return result</span>
}

// GetVersion returns the taskwarrior version.
func (to *TaskOpen) GetVersion(ctx context.Context) (string, error) <span class="cov0" title="0">{
        return to.taskClient.Version(ctx)
}</span>

// GetCurrentContext returns the current taskwarrior context.
func (to *TaskOpen) GetCurrentContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        return to.taskClient.CurrentContext(ctx)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package errors provides structured error handling with user-friendly messages.
package errors

import (
        "fmt"
        "strings"
)

// ErrorType represents different categories of errors for better user experience.
type ErrorType string

const (
        // Configuration errors
        ConfigNotFound  ErrorType = "config_not_found"
        ConfigInvalid   ErrorType = "config_invalid"
        ConfigMigration ErrorType = "config_migration"

        // Taskwarrior errors
        TaskwarriorNotFound ErrorType = "taskwarrior_not_found"
        TaskwarriorQuery    ErrorType = "taskwarrior_query"
        TaskwarriorTimeout  ErrorType = "taskwarrior_timeout"

        // Action errors
        ActionNotFound  ErrorType = "action_not_found"
        ActionInvalid   ErrorType = "action_invalid"
        ActionExecution ErrorType = "action_execution"

        // System errors
        PermissionDenied ErrorType = "permission_denied"
        FileNotFound     ErrorType = "file_not_found"
        NetworkError     ErrorType = "network_error"

        // Validation errors
        ValidationFailed ErrorType = "validation_failed"

        // Internal errors
        InternalError ErrorType = "internal_error"
)

// TaskopenError represents a structured error with user-friendly messaging.
type TaskopenError struct {
        Type        ErrorType `json:"type"`
        Message     string    `json:"message"`
        Details     string    `json:"details,omitempty"`
        Suggestions []string  `json:"suggestions,omitempty"`
        Cause       error     `json:"-"`
}

func (e *TaskopenError) Error() string <span class="cov9" title="10">{
        var parts []string

        // Main error message
        parts = append(parts, e.Message)

        // Additional details if available
        if e.Details != "" </span><span class="cov7" title="6">{
                parts = append(parts, fmt.Sprintf("Details: %s", e.Details))
        }</span>

        // Helpful suggestions
        <span class="cov9" title="10">if len(e.Suggestions) &gt; 0 </span><span class="cov8" title="7">{
                parts = append(parts, fmt.Sprintf("Suggestions:\n  ‚Ä¢ %s", strings.Join(e.Suggestions, "\n  ‚Ä¢ ")))
        }</span>

        <span class="cov9" title="10">return strings.Join(parts, "\n\n")</span>
}

func (e *TaskopenError) Unwrap() error <span class="cov1" title="1">{
        return e.Cause
}</span>

// New creates a new TaskopenError with the given type and message.
func New(errorType ErrorType, message string) *TaskopenError <span class="cov10" title="11">{
        return &amp;TaskopenError{
                Type:    errorType,
                Message: message,
        }
}</span>

// Wrap creates a new TaskopenError that wraps an existing error.
func Wrap(err error, errorType ErrorType, message string) *TaskopenError <span class="cov3" title="2">{
        return &amp;TaskopenError{
                Type:    errorType,
                Message: message,
                Cause:   err,
        }
}</span>

// WithDetails adds detailed information to an error.
func (e *TaskopenError) WithDetails(details string) *TaskopenError <span class="cov7" title="5">{
        e.Details = details
        return e
}</span>

// WithSuggestion adds a helpful suggestion to an error.
func (e *TaskopenError) WithSuggestion(suggestion string) *TaskopenError <span class="cov1" title="1">{
        e.Suggestions = append(e.Suggestions, suggestion)
        return e
}</span>

// WithSuggestions adds multiple helpful suggestions to an error.
func (e *TaskopenError) WithSuggestions(suggestions []string) *TaskopenError <span class="cov7" title="6">{
        e.Suggestions = append(e.Suggestions, suggestions...)
        return e
}</span>

// Common error constructors for frequently encountered issues

// ConfigNotFoundError creates an error for missing configuration.
func ConfigNotFoundError(path string) *TaskopenError <span class="cov1" title="1">{
        return New(ConfigNotFound, "Configuration file not found").
                WithDetails(fmt.Sprintf("Looking for config at: %s", path)).
                WithSuggestions([]string{
                        "Run 'taskopen config init' to create a new configuration",
                        "Check if the config file exists and is readable",
                        "Ensure the config directory has proper permissions",
                })
}</span>

// TaskwarriorNotFoundError creates an error for missing taskwarrior.
func TaskwarriorNotFoundError() *TaskopenError <span class="cov1" title="1">{
        return New(TaskwarriorNotFound, "Taskwarrior not found in PATH").
                WithDetails("The 'task' command is required but not available").
                WithSuggestions([]string{
                        "Install taskwarrior: sudo apt-get install taskwarrior (Ubuntu/Debian)",
                        "Install taskwarrior: brew install task (macOS)",
                        "Ensure taskwarrior is in your PATH",
                        "Run 'taskopen diagnostics' to verify installation",
                })
}</span>

// ValidationError creates an error for validation failures.
func ValidationError(field string, value string, reason string) *TaskopenError <span class="cov1" title="1">{
        return New(ValidationFailed, fmt.Sprintf("Validation failed for '%s'", field)).
                WithDetails(fmt.Sprintf("Value '%s' is invalid: %s", value, reason))
}</span>

// ActionNotFoundError creates an error for missing actions.
func ActionNotFoundError(query string) *TaskopenError <span class="cov1" title="1">{
        return New(ActionNotFound, "No matching actions found").
                WithDetails(fmt.Sprintf("No actions matched the query: %s", query)).
                WithSuggestions([]string{
                        "Check your action configuration in the config file",
                        "Verify that action patterns match your task annotations",
                        "Run 'taskopen config init' to create default actions",
                        "Use 'taskopen diagnostics' to check action configuration",
                })
}</span>

// ActionExecutionError creates an error for action execution failures.
func ActionExecutionError(actionName string, err error) *TaskopenError <span class="cov1" title="1">{
        return Wrap(err, ActionExecution, fmt.Sprintf("Failed to execute action '%s'", actionName)).
                WithSuggestions([]string{
                        "Check that the action command exists and is executable",
                        "Verify that required environment variables are set",
                        "Ensure the action has proper permissions",
                        "Check system logs for additional error details",
                })
}</span>

// PermissionDeniedError creates an error for permission issues.
func PermissionDeniedError(path string, operation string) *TaskopenError <span class="cov1" title="1">{
        return New(PermissionDenied, fmt.Sprintf("Permission denied: cannot %s %s", operation, path)).
                WithSuggestions([]string{
                        "Check file/directory permissions",
                        "Ensure you have the required access rights",
                        "Try running with appropriate privileges if necessary",
                })
}</span>

// IsType checks if an error is of a specific TaskopenError type.
func IsType(err error, errorType ErrorType) bool <span class="cov5" title="3">{
        if taskopenErr, ok := err.(*TaskopenError); ok </span><span class="cov3" title="2">{
                return taskopenErr.Type == errorType
        }</span>
        <span class="cov1" title="1">return false</span>
}

// GetType returns the ErrorType of a TaskopenError, or InternalError for other errors.
func GetType(err error) ErrorType <span class="cov3" title="2">{
        if taskopenErr, ok := err.(*TaskopenError); ok </span><span class="cov1" title="1">{
                return taskopenErr.Type
        }</span>
        <span class="cov1" title="1">return InternalError</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package exec provides secure process execution with context cancellation and sandboxing.
package exec

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strings"
        "syscall"
        "time"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
)

// ExecutionOptions configures process execution behavior.
type ExecutionOptions struct {
        // Timeout for process execution
        Timeout time.Duration

        // Environment variables (if nil, inherits current environment)
        Environment map[string]string

        // Working directory (if empty, uses current directory)
        WorkingDir string

        // Whether to capture stdout
        CaptureOutput bool

        // Whether to stream output line by line
        StreamOutput bool

        // Security sandbox options
        Sandbox SandboxOptions

        // Retry configuration
        Retry RetryOptions
}

// SandboxOptions configures process sandboxing for security.
type SandboxOptions struct {
        // Disable network access (not implemented on all platforms)
        DisableNetwork bool

        // Restrict filesystem access to specific directories
        AllowedPaths []string

        // Maximum memory usage (not implemented on all platforms)
        MaxMemoryMB int64

        // Drop privileges (Unix only)
        DropPrivileges bool
}

// RetryOptions configures retry behavior for process execution.
type RetryOptions struct {
        // Number of retry attempts
        MaxAttempts int

        // Base delay between retries
        BaseDelay time.Duration

        // Maximum delay between retries
        MaxDelay time.Duration

        // Exponential backoff multiplier
        BackoffMultiplier float64

        // Retry on these exit codes
        RetryOnExitCodes []int
}

// ExecutionResult holds the result of process execution.
type ExecutionResult struct {
        // Exit code of the process
        ExitCode int

        // Standard output (if captured)
        Stdout string

        // Standard error (if captured)
        Stderr string

        // Execution duration
        Duration time.Duration

        // Whether process was killed due to timeout
        TimedOut bool

        // Number of retry attempts made
        RetryAttempts int
}

// Executor provides secure process execution capabilities.
type Executor struct {
        // Default options for all executions
        defaultOptions ExecutionOptions
}

// New creates a new Executor with default options.
func New(options ExecutionOptions) *Executor <span class="cov0" title="0">{
        // Set reasonable defaults
        if options.Timeout == 0 </span><span class="cov0" title="0">{
                options.Timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">if options.Retry.MaxAttempts == 0 </span><span class="cov0" title="0">{
                options.Retry.MaxAttempts = 1
        }</span>

        <span class="cov0" title="0">if options.Retry.BaseDelay == 0 </span><span class="cov0" title="0">{
                options.Retry.BaseDelay = 100 * time.Millisecond
        }</span>

        <span class="cov0" title="0">if options.Retry.MaxDelay == 0 </span><span class="cov0" title="0">{
                options.Retry.MaxDelay = 5 * time.Second
        }</span>

        <span class="cov0" title="0">if options.Retry.BackoffMultiplier == 0 </span><span class="cov0" title="0">{
                options.Retry.BackoffMultiplier = 2.0
        }</span>

        <span class="cov0" title="0">return &amp;Executor{
                defaultOptions: options,
        }</span>
}

// Execute runs a command with the given options.
func (e *Executor) Execute(ctx context.Context, command string, args []string, options *ExecutionOptions) (*ExecutionResult, error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = &amp;e.defaultOptions
        }</span>

        <span class="cov0" title="0">return e.executeWithRetry(ctx, command, args, *options)</span>
}

// ExecuteFilter runs a command and returns true if exit code is 0.
func (e *Executor) ExecuteFilter(ctx context.Context, command string, args []string, options *ExecutionOptions) (bool, error) <span class="cov0" title="0">{
        result, err := e.Execute(ctx, command, args, options)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return result.ExitCode == 0, nil</span>
}

// ExecuteStream runs a command and streams output line by line.
func (e *Executor) ExecuteStream(ctx context.Context, command string, args []string, options *ExecutionOptions) (&lt;-chan string, &lt;-chan error) <span class="cov0" title="0">{
        outputChan := make(chan string, 100)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(outputChan)
                defer close(errorChan)

                if options == nil </span><span class="cov0" title="0">{
                        opts := e.defaultOptions
                        options = &amp;opts
                }</span>

                // Set streaming mode
                <span class="cov0" title="0">options.StreamOutput = true
                options.CaptureOutput = false

                if err := e.executeStream(ctx, command, args, *options, outputChan); err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                }</span>
        }()

        <span class="cov0" title="0">return outputChan, errorChan</span>
}

// executeWithRetry handles retry logic for command execution.
func (e *Executor) executeWithRetry(ctx context.Context, command string, args []string, options ExecutionOptions) (*ExecutionResult, error) <span class="cov0" title="0">{
        var lastResult *ExecutionResult
        var lastError error

        delay := options.Retry.BaseDelay

        for attempt := 0; attempt &lt; options.Retry.MaxAttempts; attempt++ </span><span class="cov0" title="0">{
                // Add retry delay (except for first attempt)
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                                // Continue with retry
                        }

                        // Exponential backoff
                        <span class="cov0" title="0">delay = time.Duration(float64(delay) * options.Retry.BackoffMultiplier)
                        if delay &gt; options.Retry.MaxDelay </span><span class="cov0" title="0">{
                                delay = options.Retry.MaxDelay
                        }</span>
                }

                <span class="cov0" title="0">result, err := e.executeSingle(ctx, command, args, options)
                if result != nil </span><span class="cov0" title="0">{
                        result.RetryAttempts = attempt
                }</span>

                // If no error and successful exit code, return success
                <span class="cov0" title="0">if err == nil &amp;&amp; result.ExitCode == 0 </span><span class="cov0" title="0">{
                        return result, nil
                }</span>

                <span class="cov0" title="0">lastResult = result
                lastError = err

                // Check if we should retry based on exit code
                if result != nil &amp;&amp; len(options.Retry.RetryOnExitCodes) &gt; 0 </span><span class="cov0" title="0">{
                        shouldRetry := false
                        for _, retryCode := range options.Retry.RetryOnExitCodes </span><span class="cov0" title="0">{
                                if result.ExitCode == retryCode </span><span class="cov0" title="0">{
                                        shouldRetry = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !shouldRetry </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        // Return the last result and error
        <span class="cov0" title="0">if lastError != nil </span><span class="cov0" title="0">{
                return lastResult, errors.Wrap(lastError, errors.ActionExecution, "Command execution failed after retries").
                        WithDetails(fmt.Sprintf("Command: %s %s", command, strings.Join(args, " "))).
                        WithSuggestion("Check command availability and arguments")
        }</span>

        <span class="cov0" title="0">return lastResult, nil</span>
}

// executeSingle executes a command once without retry logic.
func (e *Executor) executeSingle(ctx context.Context, command string, args []string, options ExecutionOptions) (*ExecutionResult, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Create context with timeout
        execCtx, cancel := context.WithTimeout(ctx, options.Timeout)
        defer cancel()

        // Create command
        cmd := exec.CommandContext(execCtx, command, args...)

        // Set working directory
        if options.WorkingDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = options.WorkingDir
        }</span>

        // Set environment
        <span class="cov0" title="0">if options.Environment != nil </span><span class="cov0" title="0">{
                env := make([]string, 0, len(options.Environment))
                for key, value := range options.Environment </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
                <span class="cov0" title="0">cmd.Env = env</span>
        }

        // Apply security sandbox
        <span class="cov0" title="0">if err := e.applySandbox(cmd, options.Sandbox); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.ActionExecution, "Failed to apply security sandbox")
        }</span>

        <span class="cov0" title="0">result := &amp;ExecutionResult{}

        // Set up output handling
        if options.CaptureOutput </span><span class="cov0" title="0">{
                var stdout, stderr strings.Builder
                cmd.Stdout = &amp;stdout
                cmd.Stderr = &amp;stderr

                // Execute command
                err := cmd.Run()

                result.Stdout = stdout.String()
                result.Stderr = stderr.String()
                result.Duration = time.Since(startTime)

                return e.handleCommandResult(cmd, err, result, execCtx)
        }</span> else<span class="cov0" title="0"> {
                // Inherit parent streams
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                cmd.Stdin = os.Stdin

                // Execute command
                err := cmd.Run()
                result.Duration = time.Since(startTime)

                return e.handleCommandResult(cmd, err, result, execCtx)
        }</span>
}

// executeStream executes a command and streams output.
func (e *Executor) executeStream(ctx context.Context, command string, args []string, options ExecutionOptions, outputChan chan&lt;- string) error <span class="cov0" title="0">{
        // Create context with timeout
        execCtx, cancel := context.WithTimeout(ctx, options.Timeout)
        defer cancel()

        // Create command
        cmd := exec.CommandContext(execCtx, command, args...)

        // Set working directory and environment
        if options.WorkingDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = options.WorkingDir
        }</span>

        <span class="cov0" title="0">if options.Environment != nil </span><span class="cov0" title="0">{
                env := make([]string, 0, len(options.Environment))
                for key, value := range options.Environment </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
                <span class="cov0" title="0">cmd.Env = env</span>
        }

        // Apply security sandbox
        <span class="cov0" title="0">if err := e.applySandbox(cmd, options.Sandbox); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ActionExecution, "Failed to apply security sandbox")
        }</span>

        // Set up output pipes
        <span class="cov0" title="0">stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ActionExecution, "Failed to create stdout pipe")
        }</span>

        <span class="cov0" title="0">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ActionExecution, "Failed to create stderr pipe")
        }</span>

        // Start command
        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errors.ActionExecution, "Failed to start command")
        }</span>

        // Stream output
        <span class="cov0" title="0">go e.streamReader(stdout, "stdout", outputChan)
        go e.streamReader(stderr, "stderr", outputChan)

        // Wait for command to complete
        return cmd.Wait()</span>
}

// streamReader reads from a pipe and sends lines to output channel.
func (e *Executor) streamReader(reader io.Reader, prefix string, outputChan chan&lt;- string) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if prefix != "" </span><span class="cov0" title="0">{
                        line = fmt.Sprintf("[%s] %s", prefix, line)
                }</span>

                <span class="cov0" title="0">select </span>{
                case outputChan &lt;- line:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel is full, drop the line to prevent blocking
                }
        }
}

// handleCommandResult processes the result of command execution.
func (e *Executor) handleCommandResult(cmd *exec.Cmd, err error, result *ExecutionResult, ctx context.Context) (*ExecutionResult, error) <span class="cov0" title="0">{
        // Check if context was cancelled (timeout or cancellation)
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                result.TimedOut = ctx.Err() == context.DeadlineExceeded
                if result.TimedOut </span><span class="cov0" title="0">{
                        return result, errors.New(errors.ActionExecution, "Command execution timed out").
                                WithDetails(fmt.Sprintf("Timeout: %v", e.defaultOptions.Timeout))
                }</span>
                <span class="cov0" title="0">return result, errors.Wrap(ctx.Err(), errors.ActionExecution, "Command execution cancelled")</span>
        }

        // Get exit code
        <span class="cov0" title="0">if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                if status, ok := exitError.Sys().(syscall.WaitStatus); ok </span><span class="cov0" title="0">{
                        result.ExitCode = status.ExitStatus()
                }</span> else<span class="cov0" title="0"> {
                        result.ExitCode = 1
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return result, errors.Wrap(err, errors.ActionExecution, "Failed to execute command")
        }</span> else<span class="cov0" title="0"> {
                result.ExitCode = 0
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// applySandbox applies security sandbox restrictions to the command.
func (e *Executor) applySandbox(cmd *exec.Cmd, sandbox SandboxOptions) error <span class="cov0" title="0">{
        // Platform-specific sandboxing implementation would go here
        // For now, we implement basic restrictions that work on most Unix systems

        if sandbox.DropPrivileges </span>{<span class="cov0" title="0">
                // This would need platform-specific implementation
                // On Unix, we could use setuid/setgid syscalls
                // For now, just document the intent
        }</span>

        // Memory limits, network restrictions, etc. would require
        // platform-specific implementations using cgroups, namespaces, etc.

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package taskwarrior provides integration with Taskwarrior task management system.
package taskwarrior

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/errors"
        "github.com/johnconnor-sec/taskopen-go/taskopen/internal/exec"
)

// DefaultArgs are the default arguments passed to taskwarrior commands.
var DefaultArgs = []string{
        "rc.verbose=blank,label,edit",
        "rc.json.array=on",
        "rc.gc=off",
}

// Task represents a Taskwarrior task.
type Task struct {
        ID          int          `json:"id,omitempty"`
        UUID        string       `json:"uuid"`
        Description string       `json:"description"`
        Status      string       `json:"status"`
        Project     string       `json:"project,omitempty"`
        Priority    string       `json:"priority,omitempty"`
        Tags        []string     `json:"tags,omitempty"`
        Annotations []Annotation `json:"annotations,omitempty"`
        Urgency     float64      `json:"urgency,omitempty"`
        Due         *time.Time   `json:"due,omitempty"`
        Created     *time.Time   `json:"entry,omitempty"`
        Modified    *time.Time   `json:"modified,omitempty"`

        // Raw JSON for additional fields
        Raw json.RawMessage `json:"-"`
}

// Annotation represents a task annotation.
type Annotation struct {
        Entry       time.Time `json:"entry"`
        Description string    `json:"description"`
}

// Context represents a Taskwarrior context.
type Context struct {
        Name   string `json:"name"`
        Filter string `json:"filter"`
}

// Client provides access to Taskwarrior functionality.
type Client struct {
        executor   *exec.Executor
        taskBinary string
        taskArgs   []string
        timeout    time.Duration
}

// NewClient creates a new Taskwarrior client.
func NewClient(taskBinary string, taskArgs []string, timeout time.Duration) *Client <span class="cov0" title="0">{
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 30 * time.Second
        }</span>

        // Configure executor with appropriate options
        <span class="cov0" title="0">execOptions := exec.ExecutionOptions{
                Timeout:       timeout,
                CaptureOutput: true,
                Retry: exec.RetryOptions{
                        MaxAttempts:       3,
                        BaseDelay:         100 * time.Millisecond,
                        MaxDelay:          2 * time.Second,
                        BackoffMultiplier: 2.0,
                        RetryOnExitCodes:  []int{}, // Don't retry on specific exit codes for now
                },
                Sandbox: exec.SandboxOptions{
                        // Taskwarrior is generally safe, but we can add restrictions if needed
                        MaxMemoryMB: 512, // Reasonable limit
                },
        }

        return &amp;Client{
                executor:   exec.New(execOptions),
                taskBinary: taskBinary,
                taskArgs:   append(DefaultArgs, taskArgs...),
                timeout:    timeout,
        }</span>
}

// Version returns the Taskwarrior version.
func (c *Client) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        args := append(c.taskArgs, "_version")

        result, err := c.executor.Execute(ctx, c.taskBinary, args, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.TaskwarriorNotFoundError()
        }</span>

        <span class="cov0" title="0">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                return "", errors.New(errors.TaskwarriorQuery, "Failed to get Taskwarrior version").
                        WithDetails(fmt.Sprintf("Exit code: %d, stderr: %s", result.ExitCode, result.Stderr)).
                        WithSuggestions([]string{
                                "Ensure Taskwarrior is installed and accessible",
                                "Check PATH environment variable",
                                "Run 'task --version' manually to verify installation",
                        })
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(result.Stdout), nil</span>
}

// CurrentContext returns the currently active Taskwarrior context.
func (c *Client) CurrentContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        args := append(c.taskArgs, "context", "show")

        result, err := c.executor.Execute(ctx, c.taskBinary, args, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, errors.TaskwarriorQuery, "Failed to get current context")
        }</span>

        <span class="cov0" title="0">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                return "", errors.New(errors.TaskwarriorQuery, "Failed to get current context").
                        WithDetails(fmt.Sprintf("Exit code: %d, stderr: %s", result.ExitCode, result.Stderr))
        }</span>

        // Parse context from output
        <span class="cov0" title="0">contextRegex1 := regexp.MustCompile(`.*with filter '(.*)' is currently applied\.$`)
        contextRegex2 := regexp.MustCompile(`.*read filter: '(.*)'$`)

        for _, line := range strings.Split(result.Stdout, "\n") </span><span class="cov0" title="0">{
                if matches := contextRegex1.FindStringSubmatch(line); matches != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("\\(%s\\)", matches[1]), nil
                }</span>
                <span class="cov0" title="0">if matches := contextRegex2.FindStringSubmatch(line); matches != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("\\(%s\\)", matches[1]), nil
                }</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// Export retrieves tasks in JSON format using streaming for large datasets.
func (c *Client) Export(ctx context.Context, filters []string) ([]Task, error) <span class="cov0" title="0">{
        args := append(c.taskArgs, filters...)
        args = append(args, "export")

        result, err := c.executor.Execute(ctx, c.taskBinary, args, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, errors.TaskwarriorQuery, "Failed to export tasks")
        }</span>

        <span class="cov0" title="0">if result.ExitCode != 0 </span><span class="cov0" title="0">{
                return nil, errors.New(errors.TaskwarriorQuery, "Taskwarrior export failed").
                        WithDetails(fmt.Sprintf("Exit code: %d, stderr: %s", result.ExitCode, result.Stderr)).
                        WithSuggestions([]string{
                                "Check task filter syntax",
                                "Ensure no tasks are locked",
                                "Verify Taskwarrior configuration",
                        })
        }</span>

        <span class="cov0" title="0">return c.parseTasksJSON(result.Stdout)</span>
}

// ExportStream retrieves tasks using streaming JSON parser for large datasets.
func (c *Client) ExportStream(ctx context.Context, filters []string) (&lt;-chan Task, &lt;-chan error) <span class="cov0" title="0">{
        taskChan := make(chan Task, 100)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(taskChan)
                defer close(errorChan)

                args := append(c.taskArgs, filters...)
                args = append(args, "export")

                // Stream output line by line
                outputChan, execErrorChan := c.executor.ExecuteStream(ctx, c.taskBinary, args, nil)

                var jsonBuffer strings.Builder
                var bracketCount int
                var inString bool
                var escaped bool

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case line, ok := &lt;-outputChan:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        // Process any remaining JSON in buffer
                                        if jsonBuffer.Len() &gt; 0 </span><span class="cov0" title="0">{
                                                tasks, err := c.parseTasksJSON(jsonBuffer.String())
                                                if err != nil </span><span class="cov0" title="0">{
                                                        errorChan &lt;- err
                                                        return
                                                }</span>

                                                <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                                                        select </span>{
                                                        case taskChan &lt;- task:<span class="cov0" title="0"></span>
                                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                                return</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">return</span>
                                }

                                // Remove prefix if present (from streaming)
                                <span class="cov0" title="0">if strings.HasPrefix(line, "[stdout] ") </span><span class="cov0" title="0">{
                                        line = strings.TrimPrefix(line, "[stdout] ")
                                }</span>

                                // Buffer the line for JSON parsing
                                <span class="cov0" title="0">jsonBuffer.WriteString(line)
                                jsonBuffer.WriteRune('\n')

                                // Simple JSON bracket counting to detect complete JSON objects
                                for _, char := range line </span><span class="cov0" title="0">{
                                        switch char </span>{
                                        case '"':<span class="cov0" title="0">
                                                if !escaped </span><span class="cov0" title="0">{
                                                        inString = !inString
                                                }</span>
                                                <span class="cov0" title="0">escaped = false</span>
                                        case '\\':<span class="cov0" title="0">
                                                escaped = !escaped &amp;&amp; inString</span>
                                        case '[':<span class="cov0" title="0">
                                                if !inString </span><span class="cov0" title="0">{
                                                        bracketCount++
                                                }</span>
                                                <span class="cov0" title="0">escaped = false</span>
                                        case ']':<span class="cov0" title="0">
                                                if !inString </span><span class="cov0" title="0">{
                                                        bracketCount--
                                                        if bracketCount == 0 </span><span class="cov0" title="0">{
                                                                // Complete JSON array, parse it
                                                                tasks, err := c.parseTasksJSON(jsonBuffer.String())
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        errorChan &lt;- err
                                                                        return
                                                                }</span>

                                                                // Send tasks to channel
                                                                <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                                                                        select </span>{
                                                                        case taskChan &lt;- task:<span class="cov0" title="0"></span>
                                                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                                                return</span>
                                                                        }
                                                                }

                                                                // Reset buffer
                                                                <span class="cov0" title="0">jsonBuffer.Reset()</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">escaped = false</span>
                                        default:<span class="cov0" title="0">
                                                escaped = false</span>
                                        }
                                }

                        case err := &lt;-execErrorChan:<span class="cov0" title="0">
                                if err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- errors.Wrap(err, errors.TaskwarriorQuery, "Failed to stream task export")
                                        return
                                }</span>

                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                errorChan &lt;- ctx.Err()
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return taskChan, errorChan</span>
}

// Query executes a Taskwarrior query and returns matching tasks.
func (c *Client) Query(ctx context.Context, filters []string) ([]Task, error) <span class="cov0" title="0">{
        // Add status:pending by default if no status filter provided
        hasStatusFilter := false
        for _, filter := range filters </span><span class="cov0" title="0">{
                if strings.Contains(filter, "status:") || strings.Contains(filter, "+PENDING") || strings.Contains(filter, "+COMPLETED") </span><span class="cov0" title="0">{
                        hasStatusFilter = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !hasStatusFilter </span><span class="cov0" title="0">{
                filters = append(filters, "+PENDING")
        }</span>

        <span class="cov0" title="0">return c.Export(ctx, filters)</span>
}

// GetTask retrieves a specific task by UUID.
func (c *Client) GetTask(ctx context.Context, uuid string) (*Task, error) <span class="cov0" title="0">{
        tasks, err := c.Export(ctx, []string{fmt.Sprintf("uuid:%s", uuid)})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(errors.TaskwarriorQuery, "Task not found").
                        WithDetails(fmt.Sprintf("UUID: %s", uuid)).
                        WithSuggestion("Verify the task UUID is correct")
        }</span>

        <span class="cov0" title="0">return &amp;tasks[0], nil</span>
}

// parseTasksJSON parses JSON output from Taskwarrior into Task structs.
func (c *Client) parseTasksJSON(jsonData string) ([]Task, error) <span class="cov0" title="0">{
        jsonData = strings.TrimSpace(jsonData)
        if jsonData == "" </span><span class="cov0" title="0">{
                return []Task{}, nil
        }</span>

        // Parse as array of raw JSON messages first to preserve all fields
        <span class="cov0" title="0">var rawTasks []json.RawMessage
        if err := json.Unmarshal([]byte(jsonData), &amp;rawTasks); err != nil </span><span class="cov0" title="0">{
                // Try parsing as single task (not array)
                var rawTask json.RawMessage
                if err2 := json.Unmarshal([]byte(jsonData), &amp;rawTask); err2 != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.TaskwarriorQuery, "Failed to parse task JSON").
                                WithDetails(fmt.Sprintf("JSON: %s", jsonData[:min(200, len(jsonData))]))
                }</span>
                <span class="cov0" title="0">rawTasks = []json.RawMessage{rawTask}</span>
        }

        <span class="cov0" title="0">tasks := make([]Task, len(rawTasks))
        for i, rawTask := range rawTasks </span><span class="cov0" title="0">{
                var task Task
                if err := json.Unmarshal(rawTask, &amp;task); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, errors.TaskwarriorQuery, "Failed to parse task").
                                WithDetails(fmt.Sprintf("Task %d in JSON array", i+1))
                }</span>

                // Store raw JSON for access to additional fields
                <span class="cov0" title="0">task.Raw = rawTask
                tasks[i] = task</span>
        }

        <span class="cov0" title="0">return tasks, nil</span>
}

// CheckTaskwarrior verifies that Taskwarrior is available and functional.
func CheckTaskwarrior(ctx context.Context, taskBinary string) error <span class="cov0" title="0">{
        client := NewClient(taskBinary, []string{}, 10*time.Second)

        version, err := client.Version(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if version == "" </span><span class="cov0" title="0">{
                return errors.New(errors.TaskwarriorNotFound, "Taskwarrior version is empty").
                        WithSuggestion("Ensure Taskwarrior is properly installed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// min returns the minimum of two integers.
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package types provides core data structures for taskopen with validation support.
package types

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// Action represents a taskopen action configuration.
// Ported from Nim Action type with validation tags.
type Action struct {
        Name          string   `json:"name" validate:"required,min=1" yaml:"name"`
        Target        string   `json:"target" validate:"required" yaml:"target"`
        Regex         string   `json:"regex" validate:"regex_pattern" yaml:"regex"`
        LabelRegex    string   `json:"labelregex" validate:"regex_pattern" yaml:"labelregex"`
        Command       string   `json:"command" validate:"required,min=1" yaml:"command"`
        Modes         []string `json:"modes" yaml:"modes"`
        FilterCommand string   `json:"filtercommand" yaml:"filtercommand"`
        InlineCommand string   `json:"inlinecommand" yaml:"inlinecommand"`
}

// Actionable represents an action that can be executed on a task.
// Ported from Nim Actionable type.
type Actionable struct {
        Text   string            `json:"text" validate:"required" yaml:"text"`
        Task   json.RawMessage   `json:"task" validate:"required" yaml:"task"`
        Entry  string            `json:"entry" validate:"required" yaml:"entry"`
        Action Action            `json:"action" validate:"required" yaml:"action"`
        Env    map[string]string `json:"env" yaml:"env"`
}

// ValidationError represents a validation error with context.
type ValidationError struct {
        Field   string `json:"field"`
        Value   string `json:"value"`
        Message string `json:"message"`
}

func (e ValidationError) Error() string <span class="cov9" title="9">{
        return fmt.Sprintf("validation failed for field '%s' with value '%s': %s", e.Field, e.Value, e.Message)
}</span>

// Validate performs validation on an Action struct.
func (a *Action) Validate() error <span class="cov10" title="11">{
        var errors []ValidationError

        // Required field validations
        if strings.TrimSpace(a.Name) == "" </span><span class="cov1" title="1">{
                errors = append(errors, ValidationError{
                        Field:   "name",
                        Value:   a.Name,
                        Message: "action name is required and cannot be empty",
                })
        }</span>

        <span class="cov10" title="11">if strings.TrimSpace(a.Target) == "" </span><span class="cov1" title="1">{
                errors = append(errors, ValidationError{
                        Field:   "target",
                        Value:   a.Target,
                        Message: "action target is required and cannot be empty",
                })
        }</span>

        <span class="cov10" title="11">if strings.TrimSpace(a.Command) == "" </span><span class="cov3" title="2">{
                errors = append(errors, ValidationError{
                        Field:   "command",
                        Value:   a.Command,
                        Message: "action command is required and cannot be empty",
                })
        }</span>

        // Regex pattern validations
        <span class="cov10" title="11">if a.Regex != "" </span><span class="cov3" title="2">{
                if _, err := regexp.Compile(a.Regex); err != nil </span><span class="cov1" title="1">{
                        errors = append(errors, ValidationError{
                                Field:   "regex",
                                Value:   a.Regex,
                                Message: fmt.Sprintf("invalid regex pattern: %v", err),
                        })
                }</span>
        }

        <span class="cov10" title="11">if a.LabelRegex != "" </span><span class="cov1" title="1">{
                if _, err := regexp.Compile(a.LabelRegex); err != nil </span><span class="cov1" title="1">{
                        errors = append(errors, ValidationError{
                                Field:   "labelregex",
                                Value:   a.LabelRegex,
                                Message: fmt.Sprintf("invalid label regex pattern: %v", err),
                        })
                }</span>
        }

        <span class="cov10" title="11">if len(errors) &gt; 0 </span><span class="cov7" title="6">{
                return &amp;ValidationErrors{Errors: errors}
        }</span>

        <span class="cov7" title="5">return nil</span>
}

// Validate performs validation on an Actionable struct.
func (a *Actionable) Validate() error <span class="cov7" title="5">{
        var errors []ValidationError

        if strings.TrimSpace(a.Text) == "" </span><span class="cov1" title="1">{
                errors = append(errors, ValidationError{
                        Field:   "text",
                        Value:   a.Text,
                        Message: "actionable text is required and cannot be empty",
                })
        }</span>

        <span class="cov7" title="5">if strings.TrimSpace(a.Entry) == "" </span><span class="cov1" title="1">{
                errors = append(errors, ValidationError{
                        Field:   "entry",
                        Value:   a.Entry,
                        Message: "actionable entry is required and cannot be empty",
                })
        }</span>

        <span class="cov7" title="5">if len(a.Task) == 0 </span><span class="cov1" title="1">{
                errors = append(errors, ValidationError{
                        Field:   "task",
                        Value:   string(a.Task),
                        Message: "task data is required and cannot be empty",
                })
        }</span>

        // Validate the embedded Action
        <span class="cov7" title="5">if err := a.Action.Validate(); err != nil </span><span class="cov1" title="1">{
                if validationErrs, ok := err.(*ValidationErrors); ok </span><span class="cov1" title="1">{
                        errors = append(errors, validationErrs.Errors...)
                }</span> else<span class="cov0" title="0"> {
                        errors = append(errors, ValidationError{
                                Field:   "action",
                                Value:   "",
                                Message: fmt.Sprintf("action validation failed: %v", err),
                        })
                }</span>
        }

        <span class="cov7" title="5">if len(errors) &gt; 0 </span><span class="cov6" title="4">{
                return &amp;ValidationErrors{Errors: errors}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ValidationErrors holds multiple validation errors.
type ValidationErrors struct {
        Errors []ValidationError `json:"errors"`
}

func (e *ValidationErrors) Error() string <span class="cov9" title="9">{
        var messages []string
        for _, err := range e.Errors </span><span class="cov9" title="9">{
                messages = append(messages, err.Error())
        }</span>
        <span class="cov9" title="9">return fmt.Sprintf("validation failed:\n  - %s", strings.Join(messages, "\n  - "))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
